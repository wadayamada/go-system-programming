# 学んだこと
- ファイルシステムは1つだけでなく、複数持てる。LinuxではVFSという仕組みで統一して扱えるようになっており、システムコール上は気にする必要がない。アプリケーションからはVFSしか見えない
  - write, readなどのシステムコールもVFSが対応する
- ファイルの管理情報をinodeに持つ。ディレクトリは配下に持つファイルの名前とinodeの一覧表を持つ、特別なファイル。ファイルの情報はファイル自体ではなく、ディレクトリにある。
  - inodeにアクセスできれば、実際のファイルの場所がわかり、実際のファイルにアクセスできる
  - VFSもinodeの仕組み
- マウント
  - ファイルシステムをVFSの管理対象に追加すること
- 論理ボリュームマネージャーで物理的なストレージを抽象化する。
  - 複数の物理ボリュームを束ねて、論理ボリュームグループと呼ばれる大きな仮想ストレージを作って、それを論理ボリュームに分割して、VFSにマウントする
  - ファイルシステムはストレージの全領域を512バイト~4キロバイトの固定長のデータ(セクター)の配列として扱う

# 面白かったこと
- ルートディレクトリは必ずinodeが2番なので、そこから辿れるようになってる
- OSはメモリバッファに書き込みができた時点で、システムコールの呼び出しの結果を返す。これにより、待ち時間が短くて済むが、電源断などが起きた場合、この時点ではメモリに書き込まれただけなので、データが消える。File.Sync()で永続化できるが、かかる時間は500倍。
- データの読み込みもバッファが最新であれば、バッファから行う。ディスクだと読み込み速度が5万倍違うらしい。
- HDDだと距離が近いファイル単位で入出力を行うことで効率化するエレベータ処理などの工夫があるが、SSDだとその処理が逆にオーバーヘッドになってしまう
- SSDはランダムアクセスが強いので、近隣にデータを集めるデフラグなどの工夫も不要になった
- SSDが高速になりすぎた結果、I/O処理命令を記録する構造体を管理するカーネルないの処理がボトルネックになったので、LinuxではCPUごとにインスタンスのキャッシュを作る改良を入れた
- SSDは上書き時に速度低下があるので、未使用領域は事前に消しておく工夫
- PostegreSQLではランダムアクセスの方がシーケンシャルアクセスより高いコストが設定されてるが、SSDではコストが変わらないので、チューニングの余地がある
- FreeBSDのmvコマンドはまずrenameシステムコールを試して、失敗したらファイルを出力先にコピーしてからソースファイルを削除してる
  - マウントされていて元のデバイスが異なる時にはrenameで移動はできない

# わからなかったこと

# やること
- [] whichコマンドをGolangで実装

# ファイルシステムは結局どういう構造なのか
上から順
- VFS
  - ファイルを扱うシステムコールを処理する
  - 複数のファイルシステムを管理して、統一したインターフェースを提供する
  - ハードリンクやシンボリックリンクもVFSを通じて提供される
    - ハードリンク: 実際のデータを共有し、同じinode番号を持つ。リンク元ファイルが削除されてもアクセスできる。同じファイルシステムでだけ利用可能
    - シンボリックリンク: ファイルやディレクトリへのパスを保持。リンク元が削除されるとアクセスできなくなる。異なるファイルシステム間でも利用可能
- ファイルシステム
  - 論理ボリュームや物理ボリューム(SSDなどの物理的なストレージ)を使ってファイルを管理できる
  - マウントすることでシステムのディレクトリツリーの一部として認識され、VFSを通じて統一的にアクセスされるようになる
- 論理ボリュームマネージャー
  - 複数のストレージを1つの論理ボリュームとして抽象化