# 学んだこと
- マルチプロセス
  - メモリ空間が別なので安全性が高い
  - スクリプト言語などだとグローバルインタプリタロックにより、これ一択のこともある
  - フォークのコピーオンライトなどによりメモリの節約はできるが、ファイルディスクリプタテーブルなどのコピーが起きるので、プロセスの起動に時間がかかる。コンテキストスイッチのコストも高い。
  - プロセスプール: 事前にフォークしてCPUコア数分のプロセスを作っておくなどの工夫はできる
  - メモリ空間が別なので、プロセス間でデータを共有するには、共有メモリ、プロセス間通信、メッセージキューなどを使う必要がある
  - Goではあまりサポートされてない。フォークとかも使えない。
- イベント駆動
  - 並列ではなく並行処理のために使われる
  - I/O負荷が高い場合
  - select属を使ってI/Oマルチプレクサのこと。複数のI/Oを1スレッドで待ち受けるやつ
  - 並列にして、複数コアを使いたい場合はイベント駆動するスレッドを複数作ったりする感じになる
- マルチスレッド
  - 複数コアを使える
  - プロセスほどではないが、OSスレッドも起動コストがかかる
  - コンテキストスイッチコストはプロセスと変わらない
  - Python, Rubyだとグローバルインタプリタロック・グローバルVMロックという機構があるので、並列処理はできるが、並行処理はできないらしい。メモリ管理をスレッドセーフにするための機能で、1プロセスで1スレッドに限定する。ロックを取ってこれを実装してる。ただ、I/O待ちの場合はこのロックを解放する。I/Oが多いなら、マルチスレッドにする余地があるかも。
- ストリーミング・プロセッシング
  - GPU
  - 32など複数のスレッドずつ同じタスクを行う
  - 複数のスレッドでIPを共有する
  - GPUでは処理できるピクセル数に比べて、画面のピクセル数の方が多いので、処理するタスクを切り替えることで、メモリ遅延に対処してる。タスク切り替えが高速なためできる。
    - 他の処理をすることでデータ待ちする
- チャネルのチャネル
  - チャネルに完了したタスクを投げるようにすることで、完了順にタスクの結果を受け取れる
  - チャネルにチャネルを投げるようにして、中のチャネルを待つようにすることで、タスクを投げた順で結果を受け取れる
- バックプレッシャー、受信側で送信量を制限する。チャネルならバッファサイズを決めることで実現できる。
- 並列for。ループ変数の実体は1つしかないから、引数を渡す時はgo funcに渡して、goroutineごとにコピーする必要がある。非同期で実行しても、コア数以上の並列化はできない点に注意。I/Oなら話は別。
- ワーカープール。OSスレッドやプロセスだと生成コストがかかるため、事前にコア数分のワーカーを作って、それを使うようにする方法がある。プロセスプール、スレッドプール、ワーカープール。goroutineだと生成コストは高くはないけど、そもそもコア数以上はスケールしないから、有効な場合もある。
- Future/Promise、今はまだ得られないが将来的に得られるデータ(Future)を使って、ロジックを実装する。将来値を用意するという約束(Promise)が果たされるとそれを使った計算が実行される。
  - goならchannelを使うことで実装できる
  - 素朴な実装だと小分けで送信が考慮されてない
  - 中断などを扱うためにcontextも必要
  - 複数のタスクが値を取ろうとするとブロックされてしまうので、キャッシュをすると良い
- ReactiveX、オブザーバーパターンを賢くしたやつ
  - channelでObservableを作る。それを受け取って処理を行うObserverを作る。その二つをSubscribeで繋ぐ。Observableにデータを流すと、それを受け取ってObserverが処理を行う。
- アクターモデル
  - 多数の小さなコンピューターが協調するモデル
  - 各アクターはメールボックスを持ち、メッセージを元に協調動作する
  - Erlang/OTPで採用されている

# 面白かったこと
- 並行は複数のタスクを実行状態にすることで、並列は複数のコアを使うこと
- goroutineでI/O処理を実行する時、非同期化はできてる。しかし、この時、CPUは使えてないので、並行だが、並列ではないと言える。
- リクエストを複数投げて、selectで複数受け取るようにすると、非同期・ブロッキングなので、I/O多重化になる。selectにdefaultをつけると、非同期・ノンブロッキングなので非同期I/Oになる

# Producer-Consumerパターン
- channelでできる
- プロセスを跨ぐならメッセージキューでできる
- メリット
  - キューイングできる
    - 大量にリクエストが来たり、重たいリクエストが来ても、キューにぶちこんで、その処理の実行はconsumerに任せることができる
    - これによって、たとえばAPIサーバーの負荷を抑えられる。APIサーバーはリクエストを捌くことに集中できる。
    - リソースが足りなくても、キューにタスクが溜まっていくだけで、サーバーダウンを抑えることができる
  - 処理をConsumerに共通化できる
    - DBを変更時にElasitcSearchを更新する処理などは、APIサーバー、CMSサーバーなど様々な場所で必要になる
  - kafkaなどにより、タスクを永続化できる
    - リトライを自動でしてくれる
    - consumerがダウンしても、kafkaにタスクが残る

# 並列・並行と非同期・同期とノンブロッキング・ブロッキング
- 並列処理
  - 複数のCPUコアを使って処理を行うこと
  - CPUがパンパンなら並列を頑張っても嬉しさはない
  - CPUが余っていた場合、複数のCPUコアを使って並列処理することで、レイテンシーが向上できる
- 同期処理
  - あるタスクの実行にあるタスクの完了が必要なこと
  - goroutineで並列処理したものを同期することもある
  - 並列処理している処理同士はお互いに待ってないので非同期と言えそう
- ブロッキング
  - 処理を止めて結果を待つ
  - 2つのタスクを並列で実行し、結果をそれぞれブロッキングで待ち、結果をがっちゃんこしないなら、並列・ブロッキング・非同期
  - 2つのタスクを並列で実行し、結果をがっちゃんこするが、結果を待っている間は自由に他の処理をできるようにした場合、並列・同期・ノンブロッキング


# やること
- [x] チャネルのチャネルを実装してみたい。早く開始した処理から処理する

# わからなかったこと 
- Future/Promise, オブザーバーパターン、ReactiveX、アクターモデルの実装はスキップした