# 学んだこと

# 面白かったこと
- JMP: ラベルにジャンプする。呼ばれる対象はプロシージャと呼ばれる
- CALL: ラベルにジャンプするがそれまで実行してた箇所をスタックに入れて、RETで戻れるようにする。呼ばれる対象はサブルーチンと言う。
- go buildではコンパイルで中間バイナリ形式のオブジェクトファイルを作った後、リンクでそれらと標準ライブラリやランタイムを結合して、実行可能なバイナリファイルを作る。リンクの時にメモリアドレスの決定も行う(実際は相対的なメモリアドレス)
- intelのx86の命令セットはさらにマイクロOpコードというCPUフレンドリーな命令セットに変換されてから実行されている
- ArmはCPUの設計のみを販売している。命令セットだけのライセンスもある
- 実装はライセンスを受けた会社ごとに行うため、他のArm CPUでは達成できない高性能を達成することがある

# 実行ファイル
- セクション単位でデータを扱う。TEXTは実行コード、DATAは静的に確保された初期化済みのメモリ領域、BSSは変数が置かれる領域
- セクションごとに権限も設定できる
- セクションをどこのメモリアドレスに置くべきかはヘッダーに書いてある
- 対応しているCPU, OS
- 必要な共有ライブラリの情報

# 実行ファイルのメモリ配置
- ASLR: アドレスレイアウト空間のランダム化
  - リンク時はグローバルオフセットテーブルに相対アドレスを記録する
  - 実行時にベースアドレスを決める
  - ベースアドレス＋相対アドレスでアクセスする
  - これによって、外部プログラムを呼び出すような危険なコードのある位置が分かりにくくなる
- 実行ファイルにzipファイルのバンドル
  - 実行ファイルの後ろにzipファイルをくっつける
  - 実行ファイルはヘッダーしか見ないので、末尾に関係ないファイルがあっても問題ない
  - zipパーサは末尾から解析するので問題ない
  - 実行時にメモリに展開されないので、好きなタイミングでメモリにロードできる

# リンカー
- _start_: OSがメモリにロードしたプログラムの最初に呼ばれる部分
- _main_: ユーザーのプログラムの最初の部分
- リンカーが実行ファイルを作る。_start_を最初に実行されるエントリーポイントとして実行ファイルを作る。
  - 実行ファイルのヘッダーにエントリーポイントのアドレスを書く
- _main_もおくべき場所に置く
- リンカーが実行ファイルのセクションをメモリのどこに置くかもヘッダーに書く
- OSはリンカーが生成した実行ファイルをシェルから起動すると、メタデータの通りにメモリに実行ファイルを配置した後、エントリーポイントからCPUで命令を実行していく。関数呼び出しなどもリンカーによってアドレス解決が行われているため、アドレスの通りにジャンプするだけ
  - プログラム実行時にOSが行うのは特定のアドレスから命令の実行を開始するだけ

# ランタイム
- C言語のランタイムの中に_start_があるので、_main_しか定義しなくても実行できる。ランタイムの最後で、_main_が呼ばれるようになってる。Goも同じ感じ。
- ランタイムライブラリがOSへのシステムコールを行なって、メモリ管理、ファイルやネットワークへのアクセスを行ってくれる
  - Cはランタイムライブラリを利用せずにプログラムを書くことができ、そのため、Linuxカーネルなどの実装もできる言語
    - この場合は、_start_も実装する必要がある
  - Goではgoroutine, channelやスライスなどのデータ構造もランタイムで提供されている。ランタイムをリンクしないとこれらが使えない。また、Goではランタイムは切り離せないようになってる。
  - 手を入れるとできなくも無いみたい。BiscuitというGo製のOSの開発など

# プログラムの実行
- 実行ファイルの実行
  - 実行ファイルに従って、セクションを適切なアドレスに配置して、パーミッションを設定する
  - スタックメモリのセクションも同様
  - 共有ライブラリも必要ならメモリに読み込む。
    - 共有ライブラリは実行時や実行途中にロードすることができる
      - chromeの拡張機能とか
      - ライブラリのバージョンを変える
      - 必要になったタイミングでロードすることで初期の起動時間の節約
      - LinuxでWindows用のバイナリをクロスコンパイルで作って、実行時にwindowsのシステム共有ライブラリを使う的な
    - 実行時に動的にロードされるため、実行時にならないと配置されるアドレスがわからないので、どこに置かれても正しく動くように、共有ライブラリは位置独立モードでコンパイルする必要がある。
- Goアプリケーションの実行
  - コンパイルすると、ランタイムの特定のファイルがエントリーポイントに指定される
  - コンパイルしたGoプログラムを実行すると以下が呼ばれる
    - goroutineの初期化
    - コマンドライン引数のパースと初期化や環境変数の初期化
    - シグナルハンドラやGCの初期化
  - init, mainを呼ぶ
- インタプリタ
  - CPUはインタプリタを実行する
  - インタプリタがテキストで書かれたプログラムを読み込んで、システムコールなどを呼ぶ
  - PythonのインタプリタはC言語のプログラム
- Pythonはコンパイラでバイトコードに変換した後、仮想マシンで実行する方式
- JavaやRubyも同じ方式だが、JITコンパイラの工夫がある。バイトコードのうち、実行頻度が高い部分をネイティブコードに変換して実行するやつ
  - 初回だけコンパイル時間がかかるので遅くなるが、2回目以降は高速になる
  - Javaはトップスピードに乗ると、C++やRustと同等の性能を叩き出す
- JavaScript
  - Babel: 新しいバージョンのJavaScriptコードから古いブラウザでも動くJavaScriptコードに変換
  - TypeScript: JavaScriptに型をつけることでコンパイル時に型チェックができるのと、型情報を使って高速化もできる
  - 高水準の言語から高水準の言語に変換することをトランスパイルという

# わからなかったこと