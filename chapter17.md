# 学んだこと
- _start_: OSがメモリにロードしたプログラムの最初に呼ばれる部分
- _main_: ユーザーのプログラムの最初の部分
- リンカーが実行ファイルを作る。_start_を最初に実行されるエントリーポイントとして実行ファイルを作る。
- ランタイムライブラリがOSへのシステムコールを行なって、メモリ管理、ファイルやネットワークへのアクセスを行ってくれる
  - Cはランタイムライブラリを利用せずにプログラムを書くことができ、そのため、Linuxカーネルなどの実装もできる言語
  - Goではgoroutine, channelやスライスなどのデータ構造もランタイムで提供されている。ランタイムをリンクしないとこれらが使えない。また、Goではランタイムは切り離せないようになってる。
  - 手を入れると手を入れるとできなくも無いみたい。BiscuitというGo製のOSの開発など
- リンカーの役割
  - 最初に実行されたい_start_を特定のアドレスに配置する
  - _main_もおくべき場所に置く
  - OSの実行ファイルのメモリへの配置を指示する実行ファイルのメタデータも書く
  - OSはリンカーが生成した実行ファイルをシェルから起動すると、メタデータの通りにメモリに実行ファイルを配置した後、エントリーポイントからCPUで命令を実行していく。関数呼び出しなどもリンカーによってアドレス解決が行われているため、アドレスの通りにジャンプするだけ
- 実行ファイル
  - ヘッダー。ブロックの意味と場所とサイズを表す。
  - セクション単位でデータを扱う。TEXTは実行コード、DATAは静的に確保された初期化済みのメモリ領域、BSSは変数が置かれる領域
  - セクションごとに権限も設定できる
  - セクションをどこのメモリアドレスに置くべきか
- 実行ファイルの実行
  - 実行ファイルに従って、セクションを適切なアドレスに配置して、パーミッションを設定する
  - スタックメモリのセクションも同様
  - 共有ライブラリも必要ならメモリに読み込む。
    - 共有ライブラリは実行時や実行途中にロードすることができる
      - chromeの拡張機能とか
      - ライブラリのバージョンを変える
      - 必要になったタイミングでロードすることで初期の起動時間の節約
      - LinuxでWindows用のバイナリをクロスコンパイルで作って、実行時にwindowsのシステム共有ライブラリを使う的な
    - 実行時に動的にロードされるため、実行時にならないと配置されるアドレスがわからないので、どこに置かれても正しく動くように、共有ライブラリは位置独立モードでコンパイルする必要がある。
- ASLR: アドレスレイアウト空間のランダム化
  - リンク時はグローバルオフセットテーブルに相対アドレスを記録する
  - 実行時にベースアドレスを決める
  - ベースアドレス＋相対アドレスでアクセスする
  - これによって、外部プログラムを呼び出すような危険なコードのある位置が分かりにくくなる
- 実行ファイルにzipファイルのバンドル
  - 実行ファイルの後ろにzipファイルをくっつける
  - 実行ファイルはヘッダーしか見ないので、末尾に関係ないファイルがあっても問題ない
  - zipパーサは末尾から解析するので問題ない
  - 実行時にメモリに展開されないので、好きなタイミングでメモリにロードできる
- Goアプリケーションの実行
  - コンパイルすると、ランタイムの特定のファイルがエントリーポイントに指定される
  - コンパイルしたGoプログラムを実行すると以下が呼ばれる
    - goroutineの初期化
    - コマンドライン引数のパースと初期化や環境変数の初期化
    - シグナルハンドラやGCの初期化
  - init, mainを呼ぶ
- インタプリタ
  - CPUはインタプリタを実行する
  - インタプリタがテキストで書かれたプログラムを読み込んで、システムコールなどを呼ぶ
  - PythonのインタプリタはC言語のプログラム
- Pythonはコンパイラでバイトコードに変換した後、仮想マシンで実行する方式
- JavaやRubyも同じ方式だが、JITコンパイラの工夫がある。バイトコードのうち、実行頻度が高い部分をネイティブコードに変換して実行するやつ
- JavaScript
  - Babel: 新しいバージョンのJavaScriptコードから古いブラウザでも動くJavaScriptコードに変換
  - TypeScript: JavaScriptに型をつけることでコンパイル時に型チェックができるのと、型情報を使って高速化もできる
  - 高水準の言語から高水準の言語に変換することをトランスパイルという

# 面白かったこと
- JMP: ラベルにジャンプする。呼ばれる対象はプロシージャと呼ばれる
- CALL: ラベルにジャンプするがそれまで実行してた箇所をスタックに入れて、RETで戻れるようにする。呼ばれる対象はサブルーチンと言う。
- C言語のランタイムの中に_start_があるので、_main_しか定義しなくても実行できる。ランタイムの最後で、_main_が呼ばれるようになってる。Goも同じ感じ。
- go buildではコンパイルで中間バイナリ形式のオブジェクトファイルを作った後、リンクでそれらと標準ライブラリやランタイムを結合して、実行可能なバイナリファイルを作る。リンクの時にメモリアドレスの決定も行う(実際は相対的なメモリアドレス)
- intelのx86はさらにマイクロOpコードに変換されて実行されている
- ArmはCPUの設計のみを販売している。命令セットだけのライセンスもある
- 実装はライセンスを受けた会社ごとに行うため、他のArm CPUでは達成できない高性能を達成することがある

# わからなかったこと
- マイクロOpコードのとこはざっと読んだだけ