# システムコールとは
特権モードで諸々の処理を行ってくれるOSの機能を呼び出すこと
OSはCPUも特権モードで実行できるため、基本的にあらゆる操作を行える。アプリケーションが特権モードを使い出すとやりたい放題になってしまうので、OSを経由するようにしてる。
メモリ割り当て、ファイル入出力、ネットワーク通信、プロセス間通信にもシステムコールが必要

# システムコールがないとどうなるか
- ターミナルで実行したプログラムの計算結果をターミナルに表示することができない
  - プログラムは別のプロセスで実行される
  - パイプや擬似端末を使ってプロセス間通信して、ターミナルに計算結果を渡して、表示する。
  - これらのプロセス間通信にはシステムコールを呼ぶ必要がある
- 実行結果をファイルに出力することもできない
  - ファイル入出力はシステムコールを呼ぶ必要がある
- メモリの取得もシステムコールを呼ぶ必要がある
  - 物理メモリの割り当ててもらって、仮想メモリを用意するにはシステムコールが必要
  - ただし、一度もらった仮想メモリの中で変数などにメモリを割り当てる際は基本的にシステムコールの呼び出しは不要
- ネットワーク通信もできない
  - 通信するためのソケット取得、ソケットにIPアドレスやポートに割り当て、ソケットのリッスン、クライアントのアクセプト、データの送受信など、全てにシステムコールが必要
- CPUを使った計算や、物理メモリ割り当て済みの仮想メモリ内での書き込み・読み込みなどはシステムコールを呼ばなくてもできる

# goでシステムコールを呼ぶ流れ
- linux
  - x86(intel系cpuやamd)
    - SYSCALL命令を呼ぶ
    - たとえばopenは、x86(32bit)の場合、SYSCALL命令の5番で、64bitの場合は2番
    - 最後まで辿るとGo言語の低レベルアセンブリ言語で書かれたコードでSYSCALLが呼ばれてる
  - arm
    - SVC命令を呼ぶ
- MacOS
  - C言語で書かれたMacOS標準ライブラリであるlibc経由でシステムコールを呼ぶ方法を現在は取っている
    - Windowsと同じくGoアプリケーションの実行時に動的にロードする
  - MacOSはlinuxと同様にSYSCALL, SVC命令を使った方式を取る、かつ、カーネルのコードが部分的に公開されてる、らしいので、Linuxみたいにlibcを使わずに呼ぶことも可能
  - MacOSがシステムコールの番号を変更したことがあり、互換性への対応のためにlibcを使う方式にした
  - MacOSはBSD系のUNIXを基盤にしたUNIX互換。システムコール番号もFreeBSDと大体同じ
  - OpenBSDはSYSCALL形式だが、セキュリティ的にlibc以外からのシステムコールを禁止してる
- windows
  - DLL(動的リンクライブラリ)をロードして、Microsoftが公開しているWin32 APIを叩いてる
    - Windowsなら必ず置いてある、kernel32.ddl, user32.ddl, shell32.ddlなどの標準ライブラリを実行時にロードする
  - Microsoftは内部のコードを公開してない、かつ、SYSCALL方式を取ってないため、直接呼べないので、この方法を取る必要がある

動的リンクライブラリってなんだっけ？

# SYSCALL命令がどう処理されるか
Linuxの場合
- 事前にwrmsrl命令を使って、entry_SYSCALL_64のポインタを特別なレジスタ(MSR_LSTAR)に登録しておく
- CPUはSYSCALL命令が呼ばれたら、システムコール番号をRAXレジスタに入れて、MSR_LSTARに入ってるentry_SYSCALL_64を呼ぶ
- entry_SYSCALL_64はシステムコール番号を見て、それに該当するシステムコールの関数を実行する
- 普通の関数呼び出しであれば、スタックメモリで引数を渡せるが、今回はユーザーモードのアプリケーションと特権モードのカーネルでの引数渡しなので、メモリ空間も別なので、レジスタ経由で引数を渡す

# goではOS間のポータビリティを自分で頑張ってる
goはLinuxの場合、libcを使わずに、SYSCALL命令を直接呼ぶ方式を取っている
過去にはMacOSもこの方式を取っていたが、システムコールの引数の変更により、リリースが遅れたりしたので、MacOSはlibcを使う方式にした。
OS標準ライブラリに依存してると、libcの種類が違ったり、バージョンが違ったりすると、同じOSとCPUアーキテクチャでも動かない可能性があるが、この方式を取ることで、OSとCPUアーキテクチャを指定するだけでクロスコンパイルできるようになる

# システムコールのモニタリング
Linuxだったらstraceでできる
MacOSだったらdtrussでできるが、SIPの解除が少し手間なのでスキップ

# やってみたい
- MacOSのシステムコール番号を使って、直接SYSCALL命令を呼んでみたい