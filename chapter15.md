# 学んだこと
- マルチプロセス
  - メモリ空間が別なので安全性が高い
  - スクリプト言語などだとボトルネックなどにより、これ一択のこともある
  - フォークのコピーオンライトなどによりメモリの節約はできるが、ファイルディスクリプタテーブルなどのコピーが起きるので、プロセスの起動に時間がかかる。コンテキストスイッチのコストも高い。
  - 事前にフォークしてCPUコア数分のプロセスを作っておくなどの工夫はできる
  - メモリ空間が別なので、プロセス間でデータを共有するには、共有メモリ、プロセス間通信、メッセージキューなどを使う必要がある
  - Goではあまりサポートされてない。フォークとかも使えない。
- イベント駆動
  - 並列ではなく並行処理のために使われる
  - I/O負荷が高い場合
  - select属を使ってI/Oマルチプレクサのこと。複数のI/Oを1スレッドで待ち受けるやつ
  - 並列にして、複数コアを使いたい場１次会合はイベント駆動するスレッドを複数作ったりする感じになる
- マルチスレッド
  - 複数コアを使える
  - プロセスほどではないが、OSスレッドも起動コストがかかる
  - コンテキストスイッチコストはプロセスと変わらない
  - Python, Rubyだとグローバルインタプリタロック・グローバルVMロックという機構があるので、並列処理はできるが、並行処理はできないらしい。メモリ管理をスレッドセーフにするための機能で、1プロセスで1スレッドに限定する。ロックを取ってこれを実装してる。ただ、I/O待ちの場合はこのロックを解放する。I/Oが多いなら、マルチスレッドにする余地があるかも。
- ストリーミング・プロセッシング
  - GPU
  - 32など複数のスレッドずつ同じタスクを行う
  - 複数のスレッドでIPを共有する
  - GPUでは処理できるピクセル数に比べて、画面のピクセル数の方が多いので、処理するタスクを切り替えることで、メモリ遅延に対処してる。タスク切り替えが高速なためできる。
- Producer-Consumerパターン
  - channelでできる
  - プロセスを跨ぐならメッセージキューでできる
- チャネルのチャネル
  - チャネルに完了したタスクを投げるようにすることで、完了順にタスクの結果を受け取れる
  - チャネルにチャネルを投げるようにして、中のチャネルを待つようにすることで、タスクを投げた順で結果を受け取れる
- バックプレッシャー、受信側で送信量を制限する。チャネルならバッファサイズを決めることで実現できる。
- 並列for。ループ変数の実体は1つしかないから、引数を渡す時はgo funcに渡して、goroutineごとにコピーする必要がある。非同期で実行しても、コア数以上の並列化はできない点に注意。I/Oなら話は別。
- ワーカープール。OSスレッドやプロセスだと生成コストがかかるため、事前にコア数分のワーカーを作って、それを使うようにする方法がある。プロセスプール、スレッドプール、ワーカープール。goroutineだと生成コストは高くはないけど、そもそもコア数以上はスケールしないから、有効な場合もある。
- Future/Promise、今はまだ得られないが将来的に得られるデータ(Future)を使って、ロジックを実装する。将来値を用意するという約束(Promise)が果たされるとそれを使った計算が実行される。
  - goならchannelを使うことで実装できる
  - 素朴な実装だと小分けで送信が考慮されてない
  - 中断などを扱うためにcontextも必要
  - 複数のタスクが値を取ろうとするとブロックされてしまうので、キャッシュをすると良い
- ReactiveX、オブザーバーパターンを賢くしたやつ
  - channelでObservableを作る。それを受け取って処理を行うObserverを作る。その二つをSubscribeで繋ぐ。Observableにデータを流すと、それを受け取ってObserverが処理を行う。
- アクターモデル
  - 多数の小さなコンピューターが協調するモデル
  - 各アクターはメールボックスを持ち、メッセージを元に協調動作する
  - Erlang/OTPで採用されている

# 面白かったこと
- CPUでは命令の実行順序を入れ替えるアウトオブオーダーでメモリの速度が遅い問題に対処してる
- 並行は複数のタスクを実行状態にすることで、並列は複数のコアを使うこと
- goroutineでI/O処理を実行する時、非同期化はできてる。しかし、この時、CPUは使えてないので、並行だが、並列ではないと言える。
- リクエストを複数投げて、selectで複数受け取るようにすると、非同期・ブロッキングなので、I/O多重化になる。selectにdefaultをつけると、非同期・ノンブロッキングなので非同期I/Oになる

# わからなかったこと 
- チャネルのチャネルを実装してみたい
- Producer-Consumerのメリットがわからん
- Futre/Primiseの実装してみたい