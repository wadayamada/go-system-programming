# 学んだこと
- シグナルはプロセス間通信とCPU割り込みハンドリングのために使われる
  - CPUの0除算エラー、メモリの範囲外アクセス、killシステムコール、ctrl+cなどによって、CPU割り込みが発生し、それを受け取ってカーネルが通知するために対象のプロセスにシグナルを送る
  - シグナルの処理自体はCPU割り込みではなく、プロセスを一時停止した後、シグナルハンドラーを実行することで行われる
- プロセスを強制終了するSIGKILLとプロセスを一時停止するSIGSTOPはアプリケーションではハンドルできない
- SIGTERMはkillシステムコールがデフォルトで送信するシグナルでサーバーアプリケーションでハンドルした方が良い
- SIGHUPはコンソールアプリケーションが擬似端末から切断される時に呼ばれる。サーバーアプリケーションはこの目的で呼ばれることはないため、設定ファイルの再読み込みを外部から指定する目的で使うことがデファクトスタンダードらしい。
- SIGINTはコンソールアプリケーションでユーザーがCtrl+C

# 面白かったこと
- 0除算エラーやメモリの範囲外アクセスなどがCPUで発生して、それをカーネルが受けて、シグナルを生成することもある
- Dockerではコンテナを終了させる時はまずSIGTERMを送るようになってる。いきなりSIGKILLで強制終了するのではなく、まずSIGTERMを送るのがお行儀が良い
- シグナルを受け取ると任意のスレッドで既存の処理を中断して、シグナル処理が強制的に走る。それは危険なので、Goではシグナル処理用のスレッドを用意している。goroutineが特定のスレッドで実行されるようにしてる。それ以外のスレッドはシグナルをブロックするようにしてる。

# シグナルのシステムコール
- シグナル送信
  - killシステムコール
  - 第二引数でシグナルの番号を指定する
- シグナル受信
  - sigactionシステムコール
  - シグナルの番号とシグナルを受信した際に実行されるハンドラー関数のポインタ
# 任意のスレッドでシグナルハンドル処理が急に走るとなぜ危険？
シグナルは実行中の処理を強制的に中断してシグナルハンドル処理が始まるため
例えば、ロックをしてる最中にシグナルが入り、同様のリソースをシグナルハンドラーがロックしようとした場合、デッドロックになる
そのため、マルチスレッド環境ではシグナル処理用のスレッドとそれ以外のスレッドを分けるのが一般的

# シグナルのGoランタイムでの内部実装
1つのOSスレッドのみがシグナルをハンドルするようにしてる
シグナル処理をするgoroutineが特定のスレッドのみで実行されるように、runtime.LockOSThreadで設定してる
また、シグナル処理スレッド以外はシグナル受信をブロックするように、pthread_sigmaskシステムコールなどを使って設定してる
アプリケーション側でシグナルを受信するように設定したり、無視するように設定されたりしたら、同じくpthread_sigmaskシステムコールを使って、シグナル処理スレッドに対して設定を変更している
シグナルを受信したら、シグナル処理スレッドではすぐにチャネルに投げるようになってるので、シグナル処理スレッドの処理量はかなり少なく、安全性が高い

# シグナルでグレイスフルリスタート
- グレイスフルリスタートはユーザー影響なしでサーバーをリスタートするやつ。Server::StarterとHttp.Server.Shutdownを組み合わせるとできる
- サーバーを起動すると、server_starterのプロセスが起動して、子プロセスとしてserverのプロセスが起動する
- 管理者は再起動したい時
  1. server_starterに管理者がシグナルを送る
  2. server_starterは新しいserverプロセスを作る
  3. server_starterは古いserverプロセスにSIGTERMシグナルを送る
  4. serverプロセスはSIGTERMシグナルが来たら、新規リクエスト受付を停止し、現在処理中のリクエストが完了したら、終了するように実装しておく
    - golangだとグレイスフルシャットダウンのメソッド(http.server.Shutdown)がある
    - Listenerを閉じることで新規リクエスト受付を停止する

# わからなかったこと

# やること
- [x] シグナルをgolangで試す。シグナルの送付とシグナルのハンドリング
