# 学んだこと
- 物理メモリはページ単位で管理されている
- プロセスは仮想メモリアドレスを見ている。仮想メモリアドレスから物理メモリへのマッピングをしてるのがページテーブル
- ページテーブルによる変換をCPUにキャッシュする仕組みがTLB
- システムで提供されている共通ライブラリはプロセスごとにロードするのではなく、全てのプロセスで共有されている
- 確保できるメモリサイズはアドレスの番地によるので、CPUのビット数による。とはいえ、アドレスの番地のマックスまでメモリを使えるわけではない。
- プロセスのユーザーのメモリ空間は、プログラム、静的変数、カーネルから動的にもらうヒープ、共有ライブラリ、スタックがこの順で置かれる
- メモリの確保はsyscall.Mmapを対象ファイルを設定せずに実行することで行える
- C言語でヒープメモリを確保するのに使う有名な標準関数はmallocで、Go言語ではそれの仲間のTCMallocを使ってる
  - 32KB以下の場合はスレッドごとにメモリを管理している、スレッドローカルキャッシュから取得する。なければ共有ヒープから取得し、それもなければOSからもらう
  - 小さいオブジェクトの場合は、サイズクラスというより小さい単位でスレッドローカルキャッシュから取得する
  - 32KB以上は、4KBのページ単位で共有ヒープから取得する
- 関数を呼ぶと、リターンアドレスや関数を実行するためのスタックフレームと呼ばれるメモリブロックが確保される。確保済みのメモリブロックに追加・削除をするだけなので、割り当てのコストはほぼゼロ。
  - OSスレッド作成時はスタック用のメモリを確保する必要があるので、コストがかかる。物理メモリを仮想メモリに割り当てて、ページテーブルも更新するという感じになるらしい。mmapを呼ぶ必要がある。
  - goroutineはスタックサイズが小さいので確保も高速。作成時にmmapを呼ばなくて済む設計になってるみたい。
- ヒープメモリはアドレスでアクセスするが、スタックメモリはLIFOなので、スタックフレームのトップを指すスタックポインタでアクセスする。
- Goで変数のデータをスタックに置くかヒープに置くかは自動で決まる。関数の中でしか使わないならスタックに置かれる。ポインタを他の関数に渡すなどする場合はヒープに置かれる
  - スタックの方が高速なのでデフォルトではスタックに置こうとする
  - 他の関数に渡されたりする場合は、ヒープに逃す
  - printしかしない場合でもヒープに移動される。変更しないならポインタではなく値を渡したほうがパフォーマンスが上がるかも。
- 配列とスライス
  - 配列は固定長
  - スライスは裏に配列があり、それを参照するウィンドウのようなもの
  - appendした時にcapacityに余裕がないと2倍のメモリを確保して、そっちのコピペする
  - メモリ確保のコスト、コピペのコスト、中間配列をGCするコストもかかる
  - 事前にサイズがわかってるなら、makeでcapacityを確保すべき
- map
  - 要素を8個ずつ、バケットととして管理する
  - keyから計算したhashの下位nビットでバケットを見つけて、上位8ビットでバケットから特定の要素を見つける
  - 要素が増えてくるとバケットを作ったり、コピペしたりするコストが生まれるため、mapも事前にmakeでcapacityを確保するのが良い
- sync.Pool
  - オブジェクトのキャッシュができる
  - Linuxにもスラブアロケータと呼ばれる、よく使うinodeとファイルディスクリプタのオブジェクトをキャッシュする仕組みがある
  - 仮想メモリにmallocでアロケートするためのコストがなくなる
  - 文字列を出力するためのバッファなどで使われてる。fmt.Fprintfではformat結果をバッファするオブジェクトが必要で、それなど
  - 初期化処理やリセット処理などもいい感じに調整できる
  - TCMallocでも似たようなことをしてる
- GC
  - 使ってないメモリを解放する
  - メモリの競合などを避けるためにプログラムの停止を伴うことがある(stop the world)
  - GoではGCが動作することが無視できるレベルでstop the worldの時間が短くなるように最適化されている
  - マークアンドスイープ: 多くの言語で採用されている基本的なGCの仕組み。到達可能なオブジェクトにマークをつけて、そうじゃないオブジェクトを解放する
  - 世代間GC: オブジェクトを寿命で老世代と若世代に分けて、若世代では頻繁にGCを実行する
  - コピーGC: 世代間GCの一部として実行されることが多い。使っているオブジェクトをfrom空間からto空間に移動することで、メモリ断片化を防ぐ
  - tri-color GC:インクリメンタルかつ並行にGCできる方式らしい
- メモリアリーナ
  - メモリの割り当てを自分でやる方式。大きなメモリ領域をアリーナとして確保して、その中での割り当て、解放はユーザーが行う。GCもアリーナは処理しない
  - mallocやTCMallocはメモリ割り当てに複雑な処理をしてるため、そのコストが小さくなる。大量の小さな値がたくさんあるプログラムでパフォーマンスが上がる可能性がある。
  - アリーナはアリーナ単位でメモリのallocateと解放を行うため、断片化が起きにくい

# 面白かったこと
- ページテーブルを使った工夫
  - デマンドページング、メモリを確保する際に実行時は物理メモリの確保まで行わずに必要になったタイミングで確保する
  - コピーオンライト
  - 共有ライブラリを複数のプロセスから見られるようにする
- メモリ断片化すると大きなメモリの確保がしにくくなる。有効活用できない。仮想メモリ空間は連続したメモリ空間を使うような設計になっているため。
# わからなかったこと
- クロージャよくわからない
- GCの雰囲気はわかったけど、JavaのGCとかちゃんと理解したい
