# 学んだこと
- 並行処理:コア数の限界を超えて処理を行う
- 並列処理:複数のコアを効率よく使う
- CPUにおける処理時間が大きい時は並列、I/O待ちなどの場合は並行で処理する
- goroutineで並列処理して、channelでデータを直列化できる
- OSは凍結したプログラムの実行状態を復元して、各スレッドを順番に処理していくこと。一回に実行する時間はスレッドごとの優先度で決まる。実行予定のスレッドはランキューに入っており、なるべく公平に実行されるようになっている
- OSスレッドはCPUにマッピングされるが、goroutineはOSスレッドにマッピングされる
- LockOSThreadを使うことで、goroutineを特定のスレッドに固定できる。そのスレッドは他のgoroutineから使われなくなる。ランタイムではシグナルを受け取るスレッドを固定するのに使ってる。
- メモリマップドI/OはI/Oデバイスをメモリ空間にマッピングすることで、通常のメモリアクセスでデバイスを操作できる仕組み。MOV命令などでできる。画面に描画するためのフレームバッファもこれを使っている。メモリマップドI/Oだと実行順序の維持とレジスタが更新されたことを確認する必要がある。sync/atomicを使うと、メモリバリアという機能で実行順序も保証してくれるらしい。
- ポートマップドI/Oは外部I/Oポートを使ってI/Oする。IN, OUT命令のやつ
- 割り込みはデバイスからCPUに通知するやつ。CPU側で割り込みハンドラの実装が必要

# 面白かったこと
- goroutineは優先度を持たない
- goroutineはタイムスライスを持たず、コンパイラが処理を切り替えるポイントを決めて、そこで切り替えるようにしてる
- goroutineはOSスレッドに比べてくらべて初期スタックメモリのサイズが小さいので、起動処理が軽い
- goroutineはOSに処理を渡さないで作成できる
- Goはプログラムカウンタ、スタックポインタ、DXの3つのレジスタを退避するだけでタスクを切り替えられるようになっている
- goroutineは起動時間、切り替え時間など、どれをとってもOSスレッドの1000倍のオーダーで高速
- goroutineによって、アプリケーションで考えることを減らして、スレッドを効率よく使える
  - リクエストごとにgoroutineを割り当てる方式でもリーズナブルなメモリ使用量で処理できる
  - OSスレッドでブロックがあると、他のスレッドに処理を切り替えるためにコンテキストスイッチが必要だが、goroutineの場合はランキューに入った他のgoroutineのタスクを実行するだけ
- Goのランタイム内部にOSスレッドにgoroutineを割り当てるスケジューラーがあり、OSスレッドごとに実行予定のgoroutineのリストがある。ランキューみたいなこれをProcessと呼んでる
- goroutineはタスクに偏りがない限り、goroutineは同じCPUコアで処理される。CPUのL1,L2のキャッシュはCPUコアごとに持ってるため、同じコアで処理するのが良い。L3はCPUコアで共有らしい。
- 現代のCPUでは余剰のCPUリソースを使って、1コアで2つ以上のスレッドを同時に実行する機構がある。GolangのOSスレッド数のデフォルト設定はそれを考慮した数になってるため、ヘビーな計算をする場合、効率的ではない場合がある
- スピンロックはロックの開放待ちをループでCPU使いながら行うこと。コンテキストスイッチしないのが嬉しい。Goだとgoroutineのコンテキストスイッチコストは低いため、この機能はない。
- sync.Mutexによって、メモリを読み込んで書き換えるコードなどに入るgoroutineを1つに制限できる。同時に実行されると問題が起きるコードをクリティカルセクションと呼ぶ。
- グローバル変数で持ってるカウンターは複数のgoroutineから同時にアクセスすると、race conditionが起きて、意図しない値になってしまうかもしれないので、sync.Mutexを使う
- sync.WaitGroupnで全てのgoroutineが終わるのを待つことができる
- sycn.Condで全てのgoroutineにタスクの完了を通知できる。チャネルでこれをやるならクローズしかないが、その場合一度きりになってしまうので、何度も送りたい場合はこっちが良い
- sync.Mapなら安全に複数のgoroutineからアクセスできる
- sync/atomicにCASと呼ばれるインテル系の命令を元にした加算・比較してスワップなどの関数が用意されている。不可分操作が提供されており、ロックなしに安全に加算などができる。sync.Mutexなどロックを使った方法の場合、ロックが発生するとOSスレッドで実行されるgoroutineが変更されるコンテキストスイッチが起きるが、この方法だと起きないため、用途が合えば、最速

# わからなかったこと
- goroutineだとランタイムがデッドロックに気づきやすいらしいが、OSスレッドとの違いがわからん
- goroutineがデッドロックした時に稼働中のgoroutineを教えてくれたり、競合状態を検出するオプションがあったり、パニック時にスタックトレースを出してくれる機能があるため、並列処理実装のデバッグがしやすいらしい。イメージがまだ掴めてない。
