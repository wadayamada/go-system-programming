# 学んだこと
- ファイル変更の監視のAPIはLinuxだとinotify系、BSD系OSはkqueue
- syscall.Flock()でファイルのロックができるが、これは強制力のないアドバイザリーロック。Windowsはこれが利用できず、代わりにLockFileEx()を使うが、これは強制ロック
- 他のプロセスの読み込みは許可する共有ロックと、全てを許可しない排他ロックがある
- syscall.Mmap()ではファイルをメモリに展開して、書き換えた内容をそのままファイルに反映もできる
- 同期・ブロッキング: I/Oをリクエストしたら、結果返ってくるまでスレッドの処理を止めて待つ(read, writeのシステムコール)
- 同期・ノンブロッキング: I/Oをリクエストしたら、結果を待たない。結果は再度I/Oリクエストして、こちらから問い合わせる。(read, writeをノンブロッキングのフラグを付与して呼ぶ)
- 非同期・ブロッキング: I/Oをリクエストしたら、結果を待たない。結果はチャネルで届くのを待つ。I/O多重化と呼ばれる。イベント駆動モデル。(select, kqueue)
- 非同期・ノンブロッキング: メインとは別のスレッドで処理を行い、結果もそっちのスレッドで受け取る。あまり使われてないが、欠点を解消したio_uringがLinuxに実装された。(非同期I/0)
- FUSEはシステムコールをユーザーランドのプロセスに転送することができて、これのインターフェースを実装することで、S3などを使ってオリジナルのファイルシステムを作れる。オリジナルのファイルシステムをマウントできる。

# 面白かったこと
- Golangでは同期・ブロッキングのI/Oが基本だが、goroutine, channelを使えば、非同期やノンブロッキングを簡単に実装できる
- システムコールのselect属とchannelのselect構文は、準備ができたタスクの通知を受け取って、処理を行うという点で同じ
- ファイルシステムを作成できれば、Webサービスから得られる情報をJSONやCSVのファイルとしてみせるようなインターフェースも実現できる

# わからなかったこと
- Mmapのコピーオンライト
- サンプルコードにあるような、同期・ノンブロッキングを実装してみたい
- オリジナルのファイルシステムのマウント楽しそう
- ソケットの使用効率をI/O多重化により実現できる？