# 学んだこと
- Dockerのコアはlibcontainerというgo製のライブラリ
- 仮想化
  - 普通のOS(ホストOS)の上にハードウェアをエミュレーションする仮想化するためのソフトウェアを用意して、その上にゲストOSをインストールする方式
  - エミュレーション方式: CPUを完全にエミュレーションすることで、他のハードウェア用のソフトウェアも動かせる。新しい高性能なCPUで古いCPU用のソフトウェアを動かしたりするのに使う。パフォーマンスは落ちる
  - ネイティブ方式: 同じアーキテクチャのCPUに限定されるが、パフォーマンスは良い
  - QEMU, VMWareなど
  - Intel系CPUには様々な仮想化支援機能が追加されてる
    - VT-x: CPUのユーザーモード、特権モードに区分けて、ハイパーバイザー用OSモード
    - 拡張ページテーブル: ゲストのメモリアドレスとホストのメモリアドレスを変換
    - VT-d: 外部デバイスとのアクセスをホストOSを介さずにできる
    - VT-c: ネットワークの仮想化
- 準仮想化
  - 完全仮想化はゲストOSが仮想化されてることを全く意識する必要がなかった。他に影響のある処理をしようとすると、ハイパーバイザが割り込み、その処理を代行するから
  - 準仮想化はゲストOSが仮想化を意識して、他に影響のある処理の代わりにhypercallでハイパーバイザを呼ぶ。Windowsなど外部からカスタムがしにくいOSの場合、開発元の協力がないと使えなかったりする。
- コンテナ
  - Linuxカーネルのコントロールグループと名前空間という昨日で実現される
  - コントロールグループ: CPU、メモリ、ネットワーク、デバイスファイルなどの使用量とアクセスを制限できる
  - 名前空間: プロセス、ネットワーク、ファイルシステム、ユーザーなどの名前空間を分離できる
  - Linuxではコンテナだけ使うが、MacOS、Windowsでは仮想化の仕組みでLinuxを動かして、その上でコンテナを動かしてる
- Windows Subsystem for Linux 2
  - 準仮想化みたいにWindowsもLinuxカーネルもハイパーバイザの上に乗っている
  - ただ、Linuxカーネルは本物の完全なLinuxカーネルが動いてるため、そういう意味では仮想化。DockerもLinux用のものが動かせる。
  - LinuxとWindowsはメモリを共有しており、Linuxは必要に応じて、Windowsにメモリを要求してメモリを取得してる
  - お互いのファイルシステムはネットワークファイルシステムを通じて見られる。ただネットワークアクセスになるのでパフォーマンスは落ちる
  - ネットワークも別々で、同じポートを使ってもエラーにならないが、お互いにアクセスもできる

# 面白かったこと

# わからなかったこと
- WSL2でネットワークファイルシステムを使って、linux, windowsがお互いのファイルシステムを見られるっていうのがどういう仕組みかよくわからない
