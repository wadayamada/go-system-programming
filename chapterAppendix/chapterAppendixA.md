# 学んだこと
- 乱数
  - math/rand
    - シードが同じだと結果が同じ
    - セキュリティ目的では使わない方が良い
    - ユーザーモードで動作する
  - crypto/rand
    - 外部要素を使って予測できないようにする
    - linuxではgetrandomシステムコールを使う
    - エントロピー(外部要素のデータ)が溜まってないと、安全性の低い乱数が生成されてしまう
- TLS
  - 通信路を暗号化して、盗聴、改ざん、再送信を防ぐ
  - TLSでサーバーにリクエストすると証明書がもらえる。認証局、認証相手、認証局の秘密鍵を使った署名、公開鍵などが書かれてる
  - 認証局を上に辿って行って、OSやブラウザが持ってるルート認証局までたどれれば、確認ができる
  - サーバーから渡された公開鍵を使ってクライアントは暗号化して送信する
  - 証明書のフィンガープリント。サーバーから渡されたハッシュ値と信頼できる認証局から受け取ったハッシュ値が一致するか確認することで、証明書の改竄がされてないことを確認できる
  - 証明書の署名値を認証局からもらった公開鍵で復号して、証明書の内容と一致すれば、認証されてることが確認できる
- SSH
  - DH鍵共有で鍵の交換をする。互いに鍵の材料を送り合い、それぞれで材料から鍵を計算する。これによって暗号化通信はできる
  - サーバーの公開鍵をクライアントに保持して、サーバーから渡される署名を確認することでなりすましを防ぐ
  - クライアントは秘密鍵を渡すことで認証する
- SCP
  - SSHセッションを通じて、標準入出力でやり取りする

# 面白かったこと
- io.Readerインターフェースで乱数を取得できる
- 乱数生成期は内部でロックが発生するため、並列でやりたいなら、goroutineのワーカーごとに用意するのが良い
- キーチェーン: OSで秘密情報を持つ仕組み

# わからなかったこと
- SCPの実装はスキップ