# 学んだこと
- HTTPはソケットのバイトストリーム上で、テキストまたはバイナリでやり取りするプロトコル
- サーバーがListenすることでリッスンソケットを作る。それに対してクライアントがDialして、サーバーがAcceptすることで通信ソケットを作り、コネクションが張られる
- Keep-Aliveはtcp connectionをcloseせずに使い回す。HTTP1.1以上を使う必要があるのと、ContentLengthを返さないと、Connection: closedが付与されてしまう。
- クライアントでAccept-Encodingを返すことで、圧縮を許可する
- Transfer-Encoding: chunkedを使うと、tcp的にはバラバラにデータを送ることができる。チャンクにサイズヘッダをつける。最後に終了チャンクを送る。
- パイプライニングは非同期にリクエスト・レスポンスを処理すること。レスポンスの順序はリクエストと同じにする必要がある。


# 面白かったこと
- tcp connectionには好きなタイミングでwriteもreadもできる。リクエスト・レスポンスという概念を作ってるのはHTTP
- Keep-AliveはKeep-Aliveっていうheaderを返したりするわけじゃないんだな
- パイプライニングの順序管理はchannelを使うことでできる
- HTTPレスポンスは別々のTCPセグメントに分けて送ることができる
  - ヘッダーは行ごととか
  - ボディは事前にContentLengthを指定するか、チャンクで別々に送れる

# わからなかったこと
- README.mdに移動

# ソケットとは
HTTP/1.0と1.1はソケットのバイトストリーム上に作られた、テキストを使ったプロトコルと言える
シグナル、メッセージキュー、パイプ、共有メモリなどと同様にプロセス間通信の一種
他のプロセス間通信と違い、アドレスとポート番号がわかれば外部のコンピュータと通信できる
サーバーがソケットを開いて待ち受ける。クライアントが開いてるソケットに接続する

# やること
- [x] keep aliveの実装
- [x] チャンクの実装