# システムコールとは
特権モードで諸々の処理を行ってくれるOSの機能を呼び出すこと
OSはCPUも特権モードで実行できるため、基本的にあらゆる操作を行える。アプリケーションが特権モードを使い出すとやりたい放題になってしまうので、OSを経由するようにしてる。
メモリ割り当て、ファイル入出力、ネットワーク通信、プロセス間通信にもシステムコールが必要

# システムコールがないとどうなるか
- ターミナルで実行したプログラムの計算結果をターミナルに表示することができない
  - プログラムは別のプロセスで実行される
  - プロセス間通信して、ターミナルに計算結果を渡して、表示してるため
  - これらのプロセス間通信にはシステムコールを呼ぶ必要がある
  - 本にはこのように書いてあるが、実行結果のターミナルへの表示は、コマンドのプロセスの標準出力先をターミナルのデバイスにすることで実現してるらしいので、プロセス間通信は行なってなさそう
- 実行結果をファイルに出力することもできない
  - ファイル入出力はシステムコールを呼ぶ必要がある
- メモリの取得もシステムコールを呼ぶ必要がある
  - 物理メモリの割り当ててもらって、仮想メモリを用意するにはシステムコールが必要
  - ただし、一度もらった仮想メモリの中で変数などにメモリを割り当てる際は基本的にシステムコールの呼び出しは不要
- ネットワーク通信もできない
  - 通信するためのソケット取得、ソケットにIPアドレスやポートに割り当て、ソケットのリッスン、クライアントのアクセプト、データの送受信など、全てにシステムコールが必要
- CPUを使った計算や、物理メモリ割り当て済みの仮想メモリ内での書き込み・読み込みなどはシステムコールを呼ばなくてもできる

# goでシステムコールを呼ぶ流れ
- linux
  - x86(intel系cpuやamd)
    - SYSCALL命令を呼ぶ
    - たとえばopenは、x86(32bit)の場合、SYSCALL命令の5番で、64bitの場合は2番
    - 最後まで辿るとGo言語の低レベルアセンブリ言語で書かれたコードでSYSCALLが呼ばれてる
  - arm
    - SVC命令を呼ぶ
- MacOS
  - C言語で書かれたMacOS標準ライブラリであるlibc経由でシステムコールを呼ぶ方法を現在は取っている
    - Windowsと同じくGoアプリケーションの実行時に動的にロードする
  - MacOSはlinuxと同様にSYSCALL, SVC命令を使った方式を取る、かつ、カーネルのコードが部分的に公開されてる、らしいので、Linuxみたいにlibcを使わずに呼ぶことも可能
  - MacOSがシステムコールの番号を変更したことがあり、互換性への対応のためにlibcを使う方式にした
  - MacOSはBSD系のUNIXを基盤にしたUNIX互換。システムコール番号もFreeBSDと大体同じ
  - OpenBSDはSYSCALL形式だが、セキュリティ的にlibc以外からのシステムコールを禁止してる
- windows
  - DLL(動的リンクライブラリ)をロードして、Microsoftが公開しているWin32 APIを叩いてる
    - Windowsなら必ず置いてある、kernel32.ddl, user32.ddl, shell32.ddlなどの標準ライブラリを実行時にロードする
  - Microsoftは内部のコードを公開してない、かつ、SYSCALL方式を取ってないため、直接呼べないので、この方法を取る必要がある

# SYSCALL命令がどう処理されるか
Linuxの場合
- 事前にwrmsrl命令を使って、entry_SYSCALL_64のポインタを特別なレジスタ(MSR_LSTAR)に登録しておく
- CPUはSYSCALL命令が呼ばれたら、システムコール番号をRAXレジスタに入れて、MSR_LSTARに入ってるentry_SYSCALL_64を呼ぶ
- entry_SYSCALL_64はシステムコール番号を見て、それに該当するシステムコールの関数を実行する
- 普通の関数呼び出しであれば、スタックメモリで引数を渡せるが、今回はユーザーモードのアプリケーションと特権モードのカーネルでの引数渡しなので、メモリ空間も別なので、レジスタ経由で引数を渡す

# goではOS間のポータビリティを自分で頑張ってる
WindowsとMacOSは標準ライブラリ使ってる

Linuxは標準ライブラリ(libc)を使わずに、SYSCALL命令、SVC命令で頑張ってる
LinuxはPOSIXでインターフェースの共通化をしてる。これのインターフェースはlibcとしてC言語の関数の呼び出しとして定義されてる。
goはこれを使ってない。POSIXを実装してないディストリビューションがあったり、POSIXのシステムコールが非効率だったりするため。
また、クロスコンパイルしにくくなったりするため。libcにも実装方式が色々あって、ubuntu, debianで使われてるglibcや、Alpine linuxで使われてるmusl libなどがあって、これらは互換性がなかったりする。

過去にはMacOSもこの方式を取っていたが、システムコールの引数の変更により、リリースが遅れたりしたので、MacOSはlibcを使う方式にした。MacOSはlibcがバージョン互換性を保つようになってるため、クロスコンパイルしても基本的に動くみたい。だが、できるだけlibcを使わない方針になってるらしい。




# システムコールのモニタリング
Linuxだったらstraceでできる
MacOSだったらdtrussでできるが、SIPの解除が少し手間なのでスキップ

# やってみたい
- MacOSのシステムコール番号を使って、直接SYSCALL命令を呼んでみたい