# 学んだこと
- 並行処理:コア数の限界を超えて処理を行う
- 並列処理:複数のコアを効率よく使う
- CPUにおける処理時間が大きい時は並列、I/O待ちなどの場合は並行で処理する
- goroutineで並列処理して、channelでデータを直列化できる
- OSは凍結したプログラムの実行状態を復元して、各スレッドを順番に処理していく。一回に実行する時間はスレッドごとの優先度で決まる。実行予定のスレッドはランキューに入っており、なるべく公平に実行されるようになっている
- OSスレッドはCPUにマッピングされるが、goroutineはOSスレッドにマッピングされる
- LockOSThreadを使うことで、goroutineを特定のスレッドに固定できる。そのスレッドは他のgoroutineから使われなくなる。ランタイムではシグナルを受け取るスレッドを固定するのに使ってる。
- ポートマップドI/Oは外部I/Oポートを使ってI/Oする。IN, OUT命令のやつ

# 面白かったこと
- goroutineは優先度を持たない
- goroutineはタイムスライスを持たず、コンパイラが処理を切り替えるポイントを決めて、そこで切り替えるようにしてる
- goroutineのコスト
  - 起動時間、切り替え時間など、どれをとってもOSスレッドの1000倍のオーダーで高速
  - goroutineはOSスレッドに比べて初期スタックメモリのサイズが小さいので、起動処理が軽い
- goroutineによって、アプリケーションで考えることを減らして、スレッドを効率よく使える
  - リクエストごとにgoroutineを割り当てる方式でもリーズナブルなメモリ使用量で処理できる
  - OSスレッドでブロックがあると、他のスレッドに処理を切り替えるためにコンテキストスイッチが必要だが、goroutineの場合はランキューに入った他のgoroutineのタスクを実行するだけ
- Goのランタイム内部にOSスレッドにgoroutineを割り当てるスケジューラーがあり、OSスレッドごとに実行予定のgoroutineのリストがある。ランキューみたいなこれをProcessと呼んでる
- タスクに偏りがない限り、goroutineは同じCPUコアで処理される。CPUのL1,L2のキャッシュはCPUコアごとに持ってるため、同じコアで処理するのが良い。L3はCPUコアで共有らしい。
- 現代のCPUでは余剰のCPUリソースを使って、1コアで2つ以上のスレッドを同時に実行する機構がある。GolangのOSスレッド数のデフォルト設定はそれを考慮した数になってるため、ヘビーな計算をする場合、効率的ではない場合がある
- スピンロックはOSスレッドでロックの開放待ちをループでCPUを使いながら行うこと(ビジーループ)。コンテキストスイッチしないのが嬉しい。Goだとgoroutineのコンテキストスイッチコストは低いため、この機能はない。
- sync.Mutexによって、メモリを読み込んで書き換えるコードなどに入るgoroutineを1つに制限できる。同時に実行されると問題が起きるコードをクリティカルセクションと呼ぶ。
- グローバル変数で持ってるカウンターは複数のgoroutineから同時にアクセスすると、race conditionが起きて、意図しない値になってしまうかもしれないので、sync.Mutexを使う
- sync.WaitGroupで全てのgoroutineが終わるのを待つことができる
- sycn.Condで全てのgoroutineにタスクの完了を通知できる。チャネルでこれをやるならクローズしかないが、その場合一度きりになってしまうので、何度も送りたい場合はこっちが良い
- sync.Mapなら安全に複数のgoroutineからアクセスできる
- goroutineはランタイムによって全て管理されてるため、デッドロックに気づきやすい。
- goroutineがデッドロックした時に稼働中のgoroutineを教えてくれたり、競合状態を検出するオプションがあったり、パニック時にスタックトレースを出してくれる機能があるため、並列処理実装のデバッグがしやすいらしい

# コンテキストスイッチ
- goroutime
  - プログラムカウンタ、スタックポインタ、データレジスタの3つのレジスタを退避するだけでタスクを切り替えられるようになっている
  - goroutineはカーネルに処理を渡さないで作成やコンテキストスイッチができる
- OSスレッド
  - スレッドの作成やコンテキストスイッチのたびにカーネルのスケジューラが必要なので、カーネルへのコンテキストスイッチコストもかかる
  - スレッドごとにスタックを持ってるので、それの切り替え
  - CPUキャッシュの切り替えが必要なこともある
- プロセス
  - CPUキャッシュミス、
  - メモリのアドレス空間の切り替え
  - ファイルディスクリプタなどの切り替え

# CPU割り込み
- CPUの0除算エラー、メモリの範囲外アクセス、killシステムコール、ctrl+c、ネットワーク通信などによって起こる
- CPUの割り込みハンドラが呼ばれる
- 割り込みハンドラ
- - メモリマップドI/Oだと実行順序の維持とレジスタが更新されたことを確認

# sync/atomicによる不可分操作
- sync/atomicにCASと呼ばれるインテル系の命令を元にした加算・比較してスワップなどの関数が用意されている。不可分操作が提供されており、ロックなしに安全に加算などができる。sync.Mutexなどロックを使った方法の場合、ロックが発生するとOSスレッドで実行されるgoroutineが変更されるコンテキストスイッチが起きるが、この方法だと起きないため、用途が合えば、最速
- カウンタや値を見て代入や値の読み書きなどは複数のgoroutineで扱う場合、race conditionが起きないようにsync.Mutexやsync.Mapを使ったロックをする必要があるが、これをロックフリーで実行できる
- BiscuitというGo製のOSでメモリマップドI/Oの実装にも使われている
  - メモリマップドI/OはI/Oデバイスをメモリ空間にマッピングすることで、通常のメモリアクセスでデバイスを操作できる仕組み。MOV命令などでできる。画面に描画するためのフレームバッファもこれを使っている。
  - CPUでは最適化のためにメモリへの書き込みの順序を変える、アウトオブオーダーという仕組みがある
  - シンプルなメモリ割り込みなら、変数への代入の順序が変わっても問題がない場合が多いが、メモリマップドI/Oだとそれがそのままディスプレイへの出力になったりするから、順序が大事になる
  - sync/atomicを使うと、メモリバリアという機能で実行順序も保証してくれるらしい。

## クロージャと引数渡し
- クロージャ
  - 関数の定義されたスコープの変数を参照できる
  - 参照渡し
  - グローバル変数と同じ挙動をするので、forでgoroutineを複数起動する時など注意が必要
- 引数渡し
  - 値渡し

# やること
- [x] sync.WaitGroupを試してみる
- [x] sync/atomicを試してみる

# わからなかったこと 
sync.CondのMutexと合わせて使う必要がある例がわからなかった