# 学んだこと
- OSから見るとタイマーやカウンタは、タスクのCPUへの割り当てやI/Oのスケジューリング、タイムアウト、ファイルのタイムスタンプなど色々な箇所で使っており、重要
- ハードウェアのタイマーで適宜調整しながら正しい時間を表示するのがリアルタイム時刻、調整の影響を受けず、巻き戻しが発生しないのがモノトニック時刻
- ウォールクロック時間は普段人間が使ってる時間で、CPU時間はCPUの実行時間。10%だったら1/10

# タイマーとカウンタ
- リアルタイムクロック: 現在時刻を保持してる、電源を切っても消えないハードウェアのクロック
- システムクロック: OSが保持する時間。電源が切れると消える。OS初期化時にリアルタイムクロックで初期化
- タイムスタンプカウンタ: CPU内蔵のカウンタ。クロック周波数をカウントしたもの。分解能が高い。マルチコアだとCPUごとにずれが生じることがある
- 各種タイマーデバイス: Linuxだと、これを使って1秒間に250回割り込みを発生させる設定にしてる。これに合わせて、システムクロックを更新したり、実行中のプロセスのタイムスライスを減らしたり、タスクの切り替えを行ったりする

# runtime.nowで現在時刻を取得できる
- windows
  - 実体はカーネル内部である、読み込み専用としてプロセスにマッピングされているメモリ領域がある
  - カーネルが100ナノ秒の精度でシステム時間をメモリに更新する
  - Goはこれを読み込んで、現在時刻を取得する
- linux
  - clock_gettimeというシステムコールで現在時刻を取得する
  - vDSOという仕組みを使ってオーバーヘッドのコストを減らしている
    - ハードウェアタイマーのイベントハンドラでメモリの時刻を更新する
    - ユーザープロセスはそれを読み込む

# タイマー処理
- タイマー処理では最終的にruntime.samesleepが呼ばれている
  - これはセマフォの獲得待ちのタイムアウトでタイマーを実装してる。5秒後なら5秒でタイムアウトを設定する。
  - 設定されているタイマーが期限の短い順で並んでおり、最新のタイマーが時間経過後にタイムアウトされ、タイマーが発火する。- 発火したら次のタイマーのタイムアウト待ちになる。
  - runtime.semawaitによって、セマフォのタイムアウト10秒待ちの後に5秒が設定された場合、5秒でタイムアウトを上書きできるらしい

# 面白かったこと
- time.Timeはモノトニック時刻も内包する。time.Addで計算した場合、リアルタイム時刻の再計算が入っても反映されないが、time.AddDateには反映されるらしい

# わからなかったこと
- チャネルを使って、タイマーを処理してるらしいがピンとこない
